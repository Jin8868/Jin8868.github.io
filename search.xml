<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unity节点编辑器(一) -- 需求分析</title>
    <url>/posts/4cce52e3.html</url>
    <content><![CDATA[最近需求的思考最近工作上在处理项目内的引导系统，我之前的做法是根据策划的需求，通过继承引导基类实现具体子类的做法，来实现不同的引导。但是这样有一个缺点：所有的引导实现都基于我的硬编码，当引导的流程变更的时候，我代码的流程也需要跟着修改，非常麻烦。而且这些变更也仅仅是步骤改变，1-&gt;2-&gt;3变成了1-&gt;3-&gt;2，修改就是纯粹的体力活，非常的琐碎。然后最近在各种机缘巧合之下，接触到了节点编辑器，突然激发了我的灵感，要是我把引导的逻辑封装在一个Node里面，由策划自己去建立Node流程，就是完全由策划编辑，我提供具体的引导Node实现，完美解决。
关于节点编辑器其实这个东西在已经应用非常广泛了，Unity的ShareGraph和UE的蓝图，都是节点编辑器的应用。而且在Unity上开源的节点编辑器框架也不少，比较出名的就有：xNode，NodeGraphProcessor。本来是打算直接使用这些框架，省下自己造轮子的时间，但是深入了解之后，发现这些框架为了通用性，代码都比较多且太重度了(我目前的需求根本用不上)。所以就想着自己造一个只提供流程的简单节点编辑器。
编辑器需求首先，因为颜值问题节点编辑器我选择了基于Unity的GraphView实现。要实现的需求：1、GraphView的创建与资源的打开。2、Node的创建、连接。3、GraphView的保存、序列化&#x2F;反序列化。4、需要具有拓展性，为之后功能提供底层复用。
代码结构因为编辑器窗口仅做显示和把数据保存，就只有model-view两层。model层为保存的Unity的so数据，view层则是解析so数据创建出对应的节点和连接。
]]></content>
  </entry>
  <entry>
    <title>Unity的==与空并运算符(？.)</title>
    <url>/posts/1bd27c8e.html</url>
    <content><![CDATA[Unity.Object使用&#x3D;&#x3D;与?.的区别众所周知，C#的判空有两种:&#x3D;&#x3D;与?.(空并运算符)，之前因为没有深入了解两种判空的在Uniyt.Object中的差别，开发的时候更是想到谁就用谁，造成了一些Crash，下面详细讲解两者的区别。
Unity.Object使用?.如上图代码和结果所示，在使用GameObject.DestroyImmediate函数当帧立即销毁之后，打印name还是执行了并且报空，说明?.无法正确的判断Unity.Object为空。
Unity.Object使用&#x3D;&#x3D;如上图代码和结果所示，在使用&#x3D;&#x3D;判断时，成功判断了对象为空。
差别的原因在解释之前，补充一段关于Unity.Object的知识。Unity运行时是C++的，所有的对象都在C++层管理，在C#层只是有一个引用对象指向C++对象。所以，就有一种情况，就是C++层的对象被销毁了，但是C#层的对象还存在，导致判空出错。了解了这个知识点，下面开始探究问题所在。以下是Unity重载&#x3D;&#x3D;运算符的源码：上面的方法用来比较两个 UnityEngine.Object 对象是否相等，lhs 和 rhs 分别代表操作符两边的参数:1.若两边参数在 CLR 层均为 null，判定相等；2.若右边参数在 CLR 层为 null，左边不为 null，根据左边参数 CLR 层所在对象对应的底层原生对象是否 Alive 返回比较结果；3.若左边参数在 CLR 层为 null，右边不为 null，根据右边参数 CLR 层所在对象对应的底层原生对象是否 Alive 返回比较结果；4.否则左右两边对象在 CLR 层对象均不为 null，比较它们的 m_InstanceID 是否相等。
在上面的测试代码中，?.是没有被Unity重载的，他仅仅只是判断对象在C#层是否为空；而&#x3D;&#x3D;不仅判断了C#层，同时也判断了C++层的引用，最终导致了两者结果的不同。
Unity.Object与System.Object判空的性能差异因为Unity.Object重载了&#x3D;&#x3D;，并且需要判断C++层的引用，所以性能一定要差于System.Object。下面是我测试代码，生成1w个Object，遍历判断是否为空，最后得出的结果Unity.Object花了0.36ms，System.Object花了0.29ms,性能差异大概是1.2倍，所以要避免在Update和轮询中对Unity.Object判空！
]]></content>
  </entry>
  <entry>
    <title>Unity节点编辑器(三) -- 创建Node节点</title>
    <url>/posts/6faec29c.html</url>
    <content><![CDATA[编辑器数据类要做的节点如下图所示根据图片可以很清晰的知道，数据分为4部分。1.要有一个类存储着所有的节点数据。2.每个节点需要保存自己的类型名字(用于反射生成)、节点唯一ID(用于标识节点)、标题、节点位置、输出&#x2F;输出端口的数据、以及一个Object类型的每个子类自己的数据。3.端口数据记录端口所在节点ID、端口唯一ID以及连接的数据。4.连接数据记录着连接的节点ID和端口。我的实现使用了Unity的ScriptableObject。数据结构的图如下。
GraphSoData 黑板数据[Serializable]public class GraphSoData : ScriptableObject&#123;    [SerializeField] public string graphName;    [SerializeField] public List&lt;NodeSoData&gt; nodeSoDataList = new List&lt;NodeSoData&gt;();    public void Dispose()    &#123;        if (nodeSoDataList != null)        &#123;            nodeSoDataList.Clear();            nodeSoDataList = null;        &#125;    &#125;&#125;
Node 节点数据[Serializable]public class NodeSoData : ScriptableObject&#123;    [SerializeField] public string nodeFullTypeName;        [SerializeField] public long nodeID;    [SerializeField] public Vector2 nodePos;    [SerializeField] public string nodeTitle;    [SerializeField] public List&lt;PortSerializationData&gt; intputPortDataList;    [SerializeField] public List&lt;PortSerializationData&gt; outputPortDataList;    [SerializeReference] public System.Object userData;&#125;
port 端口数据其中端口数据需要记录该端口自己的端口唯一ID、所属的节点ID、以及连接的信息。其中连接的信息保存的就是连接的节点与连接的端口。
[Serializable]public class LinkData&#123;    [SerializeField] public long linkPortID;    [SerializeField] public long linkNodeID;    public LinkData(long linkPortID, long linkNodeID)    &#123;        this.linkPortID = linkPortID;        this.linkNodeID = linkNodeID;    &#125;&#125;[Serializable]public class PortSerializationData&#123;    [SerializeField]    //端口ID    public long portID;    [SerializeField]    //端口所属节点ID    public long portNodeID;    [SerializeField]    //连接的端口ID    public List&lt;LinkData&gt; linkData;&#125;

NodeBase 编辑器节点基类该Node类做的是显示工作,该类继承于UnityEditor.Experimental.GraphView.Node。类中包含了NodeGraphView黑板实例、NodeSoData此Node的节点数据，以及节点大小等数据。下面是一些流程函数的说明。
初始化拿到节点数据和黑板实例后，流程先初始化数据，后初始化组件，最后刷新节点。比较简单。
public virtual void Init(NodeSoData nodeData, NodeGraphView nodeGraphView)&#123;    this.nodeGraphView = nodeGraphView;    this.nodeData = nodeData;    InitData();    InitComponent();    Refresh();&#125;public virtual void Init(NodeGraphView nodeGraphView, bool isStartNode)&#123;    this.nodeGraphView = nodeGraphView;    nodeData = GraphEditorUnility.CreateDefaultNodeData(isStartNode);    InitData();    InitComponent();    Refresh();&#125;
初始化组件这个函数比较关键，所有节点的操作都在这个函数中初始化了。拿节点数据设置位置、标题，遍历。
protected virtual void InitComponent()&#123;    AddStyle();    SetPosition(new Rect(nodeData.nodePos, Vector2.zero));    InitTitleLabel();        InitPort();        AddResizeHandle();&#125;private void InitTitleLabel()&#123;    TextField textField = new TextField()    &#123;        value = nodeData.nodeTitle    &#125;;    titleContainer.Insert(0, textField);&#125;public virtual void InitPort()&#123;    //初始化输入端口    if (nodeData.intputPortDataList != null &amp;&amp; nodeData.intputPortDataList.Count &gt; 0)    &#123;        foreach (var port in nodeData.intputPortDataList)        &#123;            InstantiatePort(port,nodeData.intputPortDataList,Direction.Input,inputContainer);        &#125;    &#125;    //初始化输出端口    if (nodeData.outputPortDataList != null &amp;&amp; nodeData.outputPortDataList.Count &gt; 0)    &#123;        foreach (var port in nodeData.outputPortDataList)        &#123;            InstantiatePort(port,nodeData.outputPortDataList,Direction.Output,outputContainer);        &#125;    &#125;&#125;//创建节点的端口实例private Port InstantiatePort(PortSerializationData portData, List&lt;PortSerializationData&gt; portDataList,Direction direction, VisualElement portContainer)&#123;    // 创建一个水平布局的容器来放置删除按钮和端口    var horizontalContainer = new VisualElement();    horizontalContainer.style.flexDirection = FlexDirection.RowReverse; // 设置为水平排列    horizontalContainer.style.alignItems = Align.Center; // 垂直居中对齐        Port newPort = InstantiatePort(Orientation.Horizontal, direction, Port.Capacity.Multi, typeof(bool));    newPort.name = string.Empty;    newPort.userData = portData;        // Button deleteButton = new Button();    // deleteButton.text = &quot;X&quot;;    // deleteButton.clicked += Click;    //    // horizontalContainer.Add(deleteButton);    horizontalContainer.Add(newPort);        portContainer.Add(horizontalContainer);    // void Click()    // &#123;    //     portDataList.Remove(portData);    //     nodeGraphView.DisconnectPort(newPort);    //     deleteButton.clicked -= Click;    //         //     portContainer.Remove(horizontalContainer);    // &#125;    return newPort;&#125;
鼠标拖动节点大小其中AddResizeHandle函数是添加了节点宽度水平拉伸。为了做到鼠标移动到右边界改变鼠标样式，所以在节点的右侧，添加一个透明的VisualElement，并且高度占满节点，宽度为5px(可以根据喜好自行修改)，其中鼠标样式需要添加到uss文件中。
//uss代码,设置一个水平的鼠标样式.resize-handle &#123;    cursor: resize-horizontal;&#125;protected virtual void AddResizeHandle()&#123;    resizeHandle = new VisualElement();    resizeHandle.style.position = Position.Absolute;    resizeHandle.style.right = 0;    resizeHandle.style.top = 0;    resizeHandle.style.bottom = 0;    resizeHandle.style.width = 10;    resizeHandle.style.backgroundColor = Color.clear;    resizeHandle.AddToClassList(&quot;resize-handle&quot;);    Add(resizeHandle);    resizeHandle.RegisterCallback&lt;MouseDownEvent&gt;(OnResizeHandleMouseDown);    resizeHandle.RegisterCallback&lt;MouseMoveEvent&gt;(OnResizeHandleMouseMove);    resizeHandle.RegisterCallback&lt;MouseUpEvent&gt;(OnResizeHandleMouseUp);&#125;//鼠标按下回调，添加一个绿框样式private void OnResizeHandleMouseDown(MouseDownEvent evt)&#123;    if (evt.button == 0) //     &#123;        isResizing = true;        resizeStartPosition = evt.mousePosition;        resizeStartSize = new Vector2(resolvedStyle.width, resolvedStyle.height);        style.borderTopWidth = 2;        style.borderBottomWidth = 2;        style.borderLeftWidth = 2;        style.borderRightWidth = 2;        style.borderTopColor = Color.green;        style.borderBottomColor = Color.green;        style.borderLeftColor = Color.green;        style.borderRightColor = Color.green;        resizeHandle.CaptureMouse();        evt.StopPropagation();    &#125;&#125;//鼠标按下移动，一直改变节点大小private void OnResizeHandleMouseMove(MouseMoveEvent evt)&#123;    if (isResizing &amp;&amp; resizeHandle.HasMouseCapture())    &#123;        Vector2 delta = evt.mousePosition - resizeStartPosition;        Vector2 newSize = resizeStartSize + new Vector2(delta.x, delta.y);        newSize.x = Mathf.Clamp(newSize.x, minSize.x, maxSize.x);        newSize.y = Mathf.Clamp(newSize.y, minSize.y, maxSize.y);        style.width = newSize.x;        RefreshPorts();        evt.StopPropagation();    &#125;&#125;//鼠标抬起设置大小private void OnResizeHandleMouseUp(MouseUpEvent evt)&#123;    if (isResizing &amp;&amp; evt.button == 0)    &#123;        isResizing = false;        resizeHandle.ReleaseMouse();        evt.StopPropagation();        style.borderTopWidth = StyleKeyword.Null;        style.borderBottomWidth = StyleKeyword.Null;        style.borderLeftWidth = StyleKeyword.Null;        style.borderRightWidth = StyleKeyword.Null;        style.borderTopColor = StyleKeyword.Null;        style.borderBottomColor = StyleKeyword.Null;        style.borderLeftColor = StyleKeyword.Null;        style.borderRightColor = StyleKeyword.Null;        OnSizeChanged();    &#125;&#125;

StartNode开始节点此节点继承于NodeBase,开始节点是每个GraphView中必备的,表示从这个节点开始往下执行。
//节点数据[Serializable]public class StartNodeData : NodeSerializationData&#123;    [SerializeField]    public bool isStartNode;    &#125;//开始节点public class StartNode : NodeBase&#123;    public StartNodeData startNodeData;        private Toggle checkBox;        protected override void InitData()    &#123;                if (nodeData.userData != null)        &#123;            startNodeData = nodeData.userData as StartNodeData;        &#125;        else        &#123;            startNodeData = new StartNodeData();            startNodeData.isStartNode = true;        &#125;    &#125;    protected override void InitComponent()    &#123;        base.InitComponent();                var horizontalContainer = new VisualElement();        horizontalContainer.style.flexDirection = FlexDirection.Row; // 设置为水平排列        horizontalContainer.style.alignItems = Align.Center; // 垂直居中对齐        checkBox = new Toggle();        checkBox.SetEnabled(false);        checkBox.value = startNodeData.isStartNode;                var label = new Label(&quot;初始节点&quot;);                horizontalContainer.Add(checkBox);        horizontalContainer.Add(label);                extensionContainer.Add(horizontalContainer);    &#125;    public override NodeSerializationData GetSerializationData()    &#123;        StartNodeData serializationData = new StartNodeData();        serializationData.isStartNode = true;        serializationData.nodeID =  nodeData.nodeID;        serializationData.outputPortDataList = nodeData.outputPortDataList;        serializationData.intputPortDataList = nodeData.intputPortDataList;        return serializationData;    &#125;&#125;

创建GraphView的So数据这里用的是Unity编辑器的菜单项，创建了一个So数据，并往里塞一个开始节点的默认数据。
[MenuItem(&quot;★Tools★/CraeteGraph&quot;)]public static void CreateGraph()&#123;    GraphEditorUnility.CreateDefaultGraph();&#125;public static void CreateDefaultGraph()&#123;    GraphSoData graph = ScriptableObject.CreateInstance&lt;GraphSoData&gt;();    int soFileCount = CountFilesExcludingMeta(DEFAULT_FILE_PATH);    string defaultFileName = string.Format(DEFAULT_FILE_NAME, soFileCount);    string defaultFilePath = System.IO.Path.Combine(DEFAULT_FILE_PATH, defaultFileName);    graph.graphName = string.Format(DEFAULT_FILE_SAVE_NAME, soFileCount);    AssetDatabase.CreateAsset(graph, defaultFilePath);    NodeSoData defaultNode = CreateDefaultNodeData(true);    graph.nodeSoDataList.Add(defaultNode);    AssetDatabase.AddObjectToAsset(defaultNode, graph);        EditorUtility.SetDirty(graph);    EditorUtility.SetDirty(defaultNode);    AssetDatabase.SaveAssets();&#125;public static NodeSoData CreateDefaultNodeData(bool isStartNode)&#123;    NodeSoData defaultSoData = ScriptableObject.CreateInstance&lt;NodeSoData&gt;();    defaultSoData.name = &quot;node&quot;;    defaultSoData.nodeID = GraphUtility.GenerateID();    defaultSoData.nodeTitle = &quot;New Node&quot;;    defaultSoData.nodePos = new Vector2(200, 200);    //起始节点加入输出node    if (isStartNode)    &#123;        defaultSoData.nodeFullTypeName = typeof(StartNode).FullName;        StartNodeData startNodeData = new StartNodeData();        startNodeData.isStartNode = true;        defaultSoData.userData = startNodeData;        defaultSoData.AddOutputPortData();    &#125;    else    &#123;        defaultSoData.nodeFullTypeName = typeof(NodeBase).FullName;    &#125;    defaultSoData.outputPortDataList = new List&lt;PortSerializationData&gt;();    defaultSoData.intputPortDataList = new List&lt;PortSerializationData&gt;();    return defaultSoData;&#125;

结果可以在菜单项创建新的节点数据，并且双击打开能看到一个开始节点。
]]></content>
  </entry>
  <entry>
    <title>Unity节点编辑器(二) -- GraphView窗口</title>
    <url>/posts/9891abd3.html</url>
    <content><![CDATA[编辑器窗口创建我这里直接用了Unity编辑器uss创建一个窗口。然后添加了一个网格样式。
窗口代码窗口中持有一个NodeGraphView实例，并且在其中OnEnable中进行初始化。
public class NodeGraphWindow : EditorWindow&#123;    protected static NodeGraphView m_graphView;    [MenuItem(&quot;★Tools★/NodeGraphWindow&quot;)]    public static void ShowExample()    &#123;        GetWindow&lt;NodeGraphWindow&gt;();    &#125;    [MenuItem(&quot;★Tools★/CraeteGraph&quot;)]    public static void CreateGraph()    &#123;        GraphEditorUnility.CreateDefaultGraph();    &#125;    [OnOpenAsset(0)]    public static bool OnOpen(int instanceID, int line)    &#123;        GraphSoData nodeGraph = EditorUtility.InstanceIDToObject(instanceID) as GraphSoData;        if (nodeGraph != null)        &#123;            Open(nodeGraph);            return true;        &#125;        return false;    &#125;    public static void Open(GraphSoData nodeGraph)    &#123;        ShowExample();        m_graphView.SetGraphData(nodeGraph);        m_graphView.RebuildGraph();    &#125;    public void OnEnable()    &#123;        Init();    &#125;    public void Init()    &#123;        rootVisualElement.style.flexDirection = FlexDirection.Column;        AddToolBar();        GraphSoData graphSoDataBase = new GraphSoData();        m_graphView = new NodeGraphView();        m_graphView.Init(graphSoDataBase);        // 让GraphView占据剩余空间        m_graphView.style.flexGrow = 1;        rootVisualElement.Add(m_graphView);    &#125;    private void AddToolBar()    &#123;        Toolbar toolbar = new Toolbar();        //// 设置工具栏样式（确保可见）        //toolbar.style.height = 30;        //// 关键修复：设置工具栏宽度为100%        //toolbar.style.width = Length.Percent(100);        //// 设置背景色使其可见        //toolbar.style.backgroundColor = new Color(0.15f, 0.15f, 0.15f);        Button saveBtn = new Button();        saveBtn.text = &quot;保存&quot;;        saveBtn.clicked += SaveBtnClick;        toolbar.Add(saveBtn);        rootVisualElement.Add(toolbar);    &#125;    private void SaveBtnClick()    &#123;        if (m_graphView == null)        &#123;            return;        &#125;        m_graphView.SaveData();    &#125;    public void OnDestroy()    &#123;        if (m_graphView != null)        &#123;            rootVisualElement.Remove(m_graphView);            m_graphView.Dispose();            m_graphView = null;        &#125;    &#125;&#125;
背景网格代码GridBackground&#123;    --grid-background-color: #2b2b2b;    --line-color: rgba(51,51,51,8);    --thick-line-color: rgba(51,51,51,1);    --spacing: 25;&#125;

GraphView 黑板GraphView有人叫视图，也有人叫黑板，后面统称为黑板。黑板这里我直接继承了Unity的GraphView，然后实现其中的接口就能实现功能，没啥技术含量上网搜索、看API文档，甚至直接问AI要代码都可以，下面是我的实现代码。
创建节点//添加右键菜单this.AddManipulator(new ContextualMenuManipulator(evt =&gt; BuildNodeCreationMenu(evt)));//创建节点菜单项private void BuildNodeCreationMenu(ContextualMenuPopulateEvent evt)&#123;    evt.menu.AppendSeparator();    var subMenu = evt.menu;    foreach (var type in nodeTypeMap)    &#123;        string itemName = $&quot;Create Node/&#123;type.Value&#125;&quot;;        subMenu.AppendAction(            itemName,            action =&gt; CreateNode(type.Key, action.eventInfo.mousePosition),            action =&gt; DropdownMenuAction.Status.Normal        );    &#125;&#125;//通过反射获取菜单项数据private void CollectNodeTypes()&#123;    nodeTypeMap.Clear();    var assemblies = AppDomain.CurrentDomain.GetAssemblies();    foreach (var assembly in assemblies)    &#123;        try        &#123;            var types = assembly.GetTypes()                .Where(t =&gt;                        (t == typeof(NodeBase) || t.IsSubclassOf(typeof(NodeBase))) &amp;&amp;                        !t.IsAbstract &amp;&amp;                        !t.IsGenericType)                    .ToList();            foreach (var type in types)            &#123;                nodeTypeMap[type] = type.FullName;            &#125;        &#125;        catch (ReflectionTypeLoadException)        &#123;                    &#125;    &#125;        nodeTypeMap = nodeTypeMap        .OrderBy(kvp =&gt; kvp.Value)        .ToDictionary(kvp =&gt; kvp.Key, kvp =&gt; kvp.Value);&#125;// 创建节点private void CreateNode(Type nodeType, Vector2 screenPosition)&#123;    Vector2 graphPosition = viewTransform.matrix.inverse.MultiplyPoint(screenPosition);    //使用反射创建了一个Node实例    NodeBase node = (NodeBase)Activator.CreateInstance(nodeType);    node.Init(this,m_graphData.nodeSoDataList.Count &lt;= 0);    node.nodeData.nodeFullTypeName = nodeType.FullName;    GraphEditorUnility.AddNodeToGraph(node.nodeData, m_graphData);    node.SetPosition(new Rect(graphPosition, Vector2.zero));    node.nodeData.nodePos = graphPosition;    AddElement(node);&#125;public static void AddNodeToGraph(NodeSoData node, GraphSoData graph)&#123;    if (node == null || graph == null)    &#123;        Debug.LogError(&quot;node or graph is null!&quot;);    &#125;    graph.nodeSoDataList.Add(node);    AssetDatabase.AddObjectToAsset(node, graph);    EditorUtility.SetDirty(graph);    EditorUtility.SetDirty(node);    AssetDatabase.SaveAssets();&#125;
拉伸、拖拽、框选//默认函数，固定写法this.AddManipulator(new ContentDragger());this.AddManipulator(new ContentZoomer());this.AddManipulator(new SelectionDragger());this.AddManipulator(new RectangleSelector());

实现完就得到一个这样的窗口，可以框选、拓展和伸缩，同时右键有创建节点的选项，但是现在还没实现NodeBase。
]]></content>
  </entry>
  <entry>
    <title>Unity节点编辑器(五) -- 引导遮罩</title>
    <url>/posts/d34f19cf.html</url>
    <content><![CDATA[遮罩需求目前市面上游戏的引导，基本上都采用了在需要突出的地方高亮引导玩家，通过点击等方式去触发下一步操作。所以需求就抽象成两个：1.高亮某一块区域2.高亮区域的点击判断和通知
高亮区域实现高亮区域有多种做法，第一种是通过继承Unity的BaseMeshEffect去自己写顶点、三角面最后形成高亮，第二种是使用Shader通过像素的判定实现。第一种比较里面的逻辑比较复杂，所以我用的是第二种。
矩形高亮区域的C#代码实现一个矩形高亮区域需要两个数据：矩形的中心和大小。为了使用同一个材质实现合批，我使用一个继承于BaseMeshEffect的类中(Unity提供的类不熟悉的可以查一下)，在类中把这两个数据写入每个顶点中。
顶点处理基类重写ModifyMesh方法，在其中使用抽象方法SetVertexData，传入顶点数据，并重新赋值出来。
public abstract class MaskVertexBase : BaseMeshEffect&#123;    public override void ModifyMesh(VertexHelper vh)    &#123;        if (!IsActive())            return;        // 准备临时列表        List&lt;UIVertex&gt; vertices = new List&lt;UIVertex&gt;();        vh.GetUIVertexStream(vertices);        // 确保每个顶点都有UV2数据        for (int i = 0; i &lt; vertices.Count; i++)        &#123;            UIVertex vertex = vertices[i];            vertices[i] = SetVertexData(vertex);        &#125;        // 清空并重新添加顶点数据        vh.Clear();        vh.AddUIVertexTriangleStream(vertices);    &#125;    /// &lt;summary&gt;    /// 设置顶点数据    /// &lt;/summary&gt;    /// &lt;param name=&quot;vertex&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    protected abstract UIVertex SetVertexData(UIVertex vertex);&#125;
矩形顶点类在具体的矩形类中，把中心位置，高度和宽度放入顶点的uv1信息中。
public class RectMaskVertex : MaskVertexBase&#123;    [Header(&quot;中心位置&quot;)]    public Vector2 centerPos;    [Header(&quot;宽度&quot;)]    public float width;    [Header(&quot;高度&quot;)]    public float height;        protected override UIVertex SetVertexData(UIVertex vertex)    &#123;        vertex.uv1.x = centerPos.x;        vertex.uv1.y = centerPos.y;        vertex.uv1.z = width;        vertex.uv1.w = height;        return vertex;    &#125;&#125;

高亮区域的Shader代码高亮逻辑有两步：1.在顶点着色器中获得像素的屏幕坐标位置。因为挂载的材质是在Unity的UI中所以model空间坐标直接就是屏幕坐标。2.在片元着色器中判断像素是否需要高亮。是否需要高亮则是对应的需求。如果是在一个矩形中，则需要判断这个像素坐标位置是否在其中，在则直接输出透明，反之输出源颜色。下面给出矩形的实现。
 v2f vert (appdata v)&#123;    v2f o;    o.screenPos = v.vertex.xy;    o.vertex = UnityObjectToClipPos(v.vertex);    o.uv = TRANSFORM_TEX(v.uv, _MainTex);    o.uv1 = v.uv1;    o.color = v.color;    return o;&#125;fixed4 frag (v2f i) : SV_Target&#123;    fixed4 col = tex2D(_MainTex, i.uv)*i.color;    float2 centerPos = i.uv1.xy;    float width = i.uv1.z / 2;    float height = i.uv1.w / 2;    float2 offset = i.screenPos.xy - centerPos;    col.a *= (abs(offset.x) &gt; width) || (abs(offset.y) &gt; height);         return col;&#125;

高亮区域的点击判断和通知判断是否点击到了高亮区域，这个逻辑需要在C#端实现。在顶点处理基类中继承了IPointerClickHandler, IPointerEnterHandler, IPointerDownHandler, IPointerUpHandler, IPointerExitHandler, IPointerMoveHandler这几个接口去监听点击输入，并且抽象了一个判断是否在高亮区域内的委托，在具体的业务中添加进来。只需要在点击的时候执行委托进行判定，若判定为true则通过eventSystem.RaycastAll(eventData, raycastResult)获得当前高亮后的，所有的可点击物体，然后遍历去执行第一个GameObject的点击。下面给出完整的MaskVertexBase代码
using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public delegate bool PointerEventCallback(PointerEventData eventData);/// &lt;summary&gt;/// 遮罩的定点类，负责设置遮罩的顶点数据/// &lt;/summary&gt;[RequireComponent(typeof(Image))]public abstract class MaskVertexBase : BaseMeshEffect, IPointerClickHandler, IPointerEnterHandler, IPointerDownHandler, IPointerUpHandler, IPointerExitHandler, IPointerMoveHandler&#123;    [Header(&quot;向Shader传递的数据&quot;)]    public AdditionalCanvasShaderChannels additionalCanvasShaderChannels;    protected Canvas canvas;    protected Camera uiCamera;    protected RectTransform canvansRect;    protected RectTransform rectTransform;    [HideInInspector]    public EventSystem eventSystem;    [HideInInspector]    public PointerEventCallback raycastLocationValid;    private List&lt;RaycastResult&gt; raycastResult;    private GameObject m_lastHoverGameObject;    protected virtual void OnEnable()    &#123;        base.OnEnable();        if (canvas == null)        &#123;            canvas = transform.GetComponentInParent&lt;Canvas&gt;();            uiCamera = canvas.worldCamera;            rectTransform = transform.GetComponent&lt;RectTransform&gt;();            canvansRect = canvas.transform.GetComponent&lt;RectTransform&gt;();            raycastResult = new List&lt;RaycastResult&gt;();            AdditionalCanvasShaderChannels();        &#125;    &#125;    public override void ModifyMesh(VertexHelper vh)    &#123;        if (!IsActive())            return;        // 准备临时列表        List&lt;UIVertex&gt; vertices = new List&lt;UIVertex&gt;();        vh.GetUIVertexStream(vertices);        // 确保每个顶点都有UV2数据        for (int i = 0; i &lt; vertices.Count; i++)        &#123;            UIVertex vertex = vertices[i];            vertices[i] = SetVertexData(vertex);        &#125;        // 清空并重新添加顶点数据        vh.Clear();        vh.AddUIVertexTriangleStream(vertices);    &#125;    /// &lt;summary&gt;    /// 设置顶点数据    /// &lt;/summary&gt;    /// &lt;param name=&quot;vertex&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    protected abstract UIVertex SetVertexData(UIVertex vertex);    /// &lt;summary&gt;    /// 添加Canvas向Shader传递的数据    /// &lt;/summary&gt;    protected virtual void AdditionalCanvasShaderChannels()    &#123;        if (canvas == null)        &#123;            return;        &#125;        if (additionalCanvasShaderChannels == UnityEngine.AdditionalCanvasShaderChannels.None)        &#123;            return;        &#125;        if ((canvas.additionalShaderChannels &amp; additionalCanvasShaderChannels) == 0)        &#123;            canvas.additionalShaderChannels |= additionalCanvasShaderChannels;            graphic.SetVerticesDirty();        &#125;    &#125;    #region 对外方法    public void SetEventSystem(EventSystem eventSystem)    &#123;        this.eventSystem = eventSystem;    &#125;        public bool GetLocalPointByScreenPos(Vector2 screenPos, out Vector2 localPoint)    &#123;        if (RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPos, uiCamera, out localPoint))        &#123;            return true;        &#125;        return false;    &#125;    public bool GetLocalPointByWorldPos(Vector3 worldPos, Camera watchCamera, out Vector2 localPoint)    &#123;        Vector3 screenPos = watchCamera.WorldToScreenPoint(worldPos);        if (GetLocalPointByScreenPos(screenPos, out localPoint))        &#123;            return true;        &#125;        return false;    &#125;    public Camera GetCanvasWorldCamera()    &#123;        return uiCamera;    &#125;    #endregion    #region 点击实现    private void CheckAndChangeHover(GameObject newHoverGameObject, PointerEventData eventData)    &#123;        if (newHoverGameObject != m_lastHoverGameObject)        &#123;            if (m_lastHoverGameObject != null)            &#123;                ExecuteEvents.Execute(m_lastHoverGameObject, eventData, ExecuteEvents.pointerExitHandler);            &#125;            if (newHoverGameObject != null)            &#123;                ExecuteEvents.Execute(newHoverGameObject, eventData, ExecuteEvents.pointerEnterHandler);            &#125;            m_lastHoverGameObject = newHoverGameObject;        &#125;    &#125;    protected virtual GameObject PassEvent&lt;T&gt;(PointerEventData eventData, ExecuteEvents.EventFunction&lt;T&gt; function) where T : IEventSystemHandler    &#123;        raycastResult.Clear();        eventSystem.RaycastAll(eventData, raycastResult);        bool isExecute = false;        foreach (var result in raycastResult)        &#123;            if (result.gameObject == transform.gameObject)            &#123;                continue;            &#125;            isExecute = ExecuteEvents.Execute(result.gameObject, eventData, function);            return result.gameObject;        &#125;        return null;    &#125;    protected virtual GameObject CheckRaycastLocationValid&lt;T&gt;(PointerEventData eventData, ExecuteEvents.EventFunction&lt;T&gt; function) where T : IEventSystemHandler    &#123;        if (raycastLocationValid != null)        &#123;            bool isCanClick = raycastLocationValid.Invoke(eventData);            if (isCanClick)            &#123;                return PassEvent(eventData, function);            &#125;            // 判断 function 是否指向 pointerClickHandler            if (typeof(T) == typeof(IPointerClickHandler) &amp;&amp;                 function.Method == ExecuteEvents.pointerClickHandler.Method)            &#123;                MessageSystem.Instance.SendMessage(MessageDefine.MASK_CLICK);            &#125;        &#125;        return null;    &#125;    public virtual void OnPointerClick(PointerEventData eventData)    &#123;                var result = CheckRaycastLocationValid(eventData, ExecuteEvents.pointerClickHandler);        if (result != null)        &#123;            MessageSystem.Instance.SendMessage(MessageDefine.MASK_HIGH_LINGHT_CLICK);                   &#125;    &#125;    public virtual void OnPointerEnter(PointerEventData eventData)    &#123;        CheckRaycastLocationValid(eventData, ExecuteEvents.pointerEnterHandler);    &#125;    public virtual void OnPointerDown(PointerEventData eventData)    &#123;        CheckRaycastLocationValid(eventData, ExecuteEvents.pointerDownHandler);    &#125;    public virtual void OnPointerUp(PointerEventData eventData)    &#123;        CheckRaycastLocationValid(eventData, ExecuteEvents.pointerUpHandler);    &#125;    public void OnPointerExit(PointerEventData eventData)    &#123;        CheckRaycastLocationValid(eventData, ExecuteEvents.pointerExitHandler);    &#125;    public void OnPointerMove(PointerEventData eventData)    &#123;        GameObject enterObject = CheckRaycastLocationValid(eventData, ExecuteEvents.pointerMoveHandler);        CheckAndChangeHover(enterObject, eventData);    &#125;    #endregion#if UNITY_EDITOR    void OnValidate()    &#123;        if (graphic != null)        &#123;            graphic.SetVerticesDirty();            AdditionalCanvasShaderChannels();        &#125;    &#125;#endif&#125;

遮罩预览
]]></content>
  </entry>
  <entry>
    <title>Unity节点编辑器(四) -- 保存&amp;打开Graph数据</title>
    <url>/posts/92b1d9a5.html</url>
    <content><![CDATA[打开SO数据使用Unity内置函数添加双击打开事件使用Unity提供的OnOpenAsset(0)，然后重新设置graphView的数据并重绘。
[OnOpenAsset(0)]public static bool OnOpen(int instanceID, int line)&#123;    GraphSoData nodeGraph = EditorUtility.InstanceIDToObject(instanceID) as GraphSoData;    if (nodeGraph != null)    &#123;        Open(nodeGraph);        return true;    &#125;    return false;&#125;public static void Open(GraphSoData nodeGraph)&#123;    ShowExample();    m_graphView.SetGraphData(nodeGraph);    m_graphView.RebuildGraph();&#125;

获取So数据后进行节点的创建RebuildGraph函数先清空原有的所有节点和节点连接，再重新创建。
public void RebuildGraph()&#123;    ClearNodeAndEdge();    CreateNode(m_graphData.nodeSoDataList);&#125;
清空节点contentContainer是Unity节点内的所有元素的容器，遍历这个容器，把NodeBase和Edge删除。
public virtual void ClearNodeAndEdge()&#123;    if (contentContainer == null || contentContainer.childCount &lt;= 0)    &#123;        return;    &#125;    for (int i = contentContainer.childCount - 1; i &gt;= 0; i--)    &#123;        var elementItem = contentContainer.ElementAt(i);        //???Node        if (elementItem is NodeBase node)        &#123;            contentContainer.RemoveAt(i);        &#125;        //???Edge        if (elementItem is Edge edge)        &#123;            contentContainer.RemoveAt(i);        &#125;    &#125;&#125;
创建节点拿到GraphSoData中的NodeSoData列表信息进行遍历。对每个Node数据信息，拿到TypeName后使用反射实例化出具体的Node子类，随后通过AddElement函数把Node添加到图中管理。
public virtual List&lt;NodeBase&gt; CreateNode(List&lt;NodeSoData&gt; nodeDataList)&#123;    if (nodeDataList == null || nodeDataList.Count &lt;= 0)    &#123;        return null;    &#125;    List&lt;NodeBase&gt; nodeViewList = new List&lt;NodeBase&gt;(nodeDataList.Count);    foreach (NodeSoData node in nodeDataList)    &#123;        Type nodeType = Type.GetType(node.nodeFullTypeName);        NodeBase newNode = (NodeBase)Activator.CreateInstance(nodeType);        newNode.Init(node, this);        nodeViewList.Add(newNode);        AddElement(newNode);    &#125;        LinkNode();    return nodeViewList;&#125;
创建连接为了避免找不到未生成节点的先后顺序问题，所以在所有的节点创建完成后，再进行节点连接的创建。节点之间的连接通过之前记录在端口中的LinkData数据，通过节点ID和端口ID找到唯一的端口，并通过ConnectTo函数连接两个节点，最后把Edge连接通过AddElement函数添加到Graph中管理。
protected virtual void LinkNode()&#123;    foreach (var node in nodes)    &#123;        NodeBase nodeBase = node as NodeBase;        if (nodeBase == null)        &#123;            continue;        &#125;        foreach (var portData in nodeBase.nodeData.outputPortDataList)        &#123;            long curPortID = portData.portID;            Port curPort = GetPortByID(curPortID);            foreach (var linkData in portData.linkData)            &#123;                long linkPortID = linkData.linkPortID;                Port linkPort = GetPortByID(linkPortID);                if (linkPort == null)                &#123;                    Debug.LogError($&quot;nodeID=&#123;nodeBase.nodeData.nodeID&#125; linkPortID=&#123;linkPortID&#125;,port is null&quot;);                &#125;                var edge = curPort.ConnectTo(linkPort);                AddElement(edge);            &#125;        &#125;    &#125;&#125;
保存运行时序列化数据前面的GraphSoData是仅作为编辑器使，而且运行时的时候比如一些节点的大小、位置这些信息是用不到的。为了数据的精简和高效，所以在原有的NodeSoData创建了一个NodeSerializationData用于保存运行时序列化信息。在运行时一张图就转变为一个List数据。这个NodeSerializationData数据由NodeBase提供一个虚方法，并由各个具体的子类继承实现。
public virtual NodeSerializationData GetSerializationData()&#123;    return new NodeSerializationData(nodeData);&#125;

窗口添加保存按钮在对应的windows窗口中添加一个ToolBar并在其中添加一个按钮。
private void AddToolBar()&#123;    Toolbar toolbar = new Toolbar();    //// 设置工具栏样式（确保可见）    //toolbar.style.height = 30;    //// 关键修复：设置工具栏宽度为100%    //toolbar.style.width = Length.Percent(100);    //// 设置背景色使其可见    //toolbar.style.backgroundColor = new Color(0.15f, 0.15f, 0.15f);    Button saveBtn = new Button();    saveBtn.text = &quot;保存&quot;;    saveBtn.clicked += SaveBtnClick;    toolbar.Add(saveBtn);    rootVisualElement.Add(toolbar);&#125;private void SaveBtnClick()&#123;    if (m_graphView == null)    &#123;        return;    &#125;    m_graphView.SaveData();&#125;
核心逻辑为调用GraphView中的SaveData接口，在里面遍历所有的Nodebase的获取序列化数据的接口，并且获得数据都存入list容器中最后写入文件。我这里的处理办法比较简单粗暴，用了NewtonJson去序列化每个Node信息后直接使用|去分割每个Node的信息后序列化成了string保存起来。可以使用protobuf等二进制数据去序列化，进一步地优化文件的体积大小。
public virtual void SaveData()&#123;    List&lt;NodeSerializationData&gt; nodeSaveData = new List&lt;NodeSerializationData&gt;();    foreach (var node in nodes)    &#123;        if (node == null)        &#123;            continue;        &#125;        if (node is NodeBase nodeBase)        &#123;            nodeSaveData.Add(nodeBase.GetSerializationData());        &#125;    &#125;    if (nodeSaveData.Count &lt;= 0)    &#123;        Debug.Log(&quot;Graph的Node数量为0!&quot;);        return;    &#125;    // string data = MergeUnsafe(nodeSaveData);    var data = MergeNodeData(nodeSaveData);    GraphEditorUnility.SaveDataToBytes(data, m_graphData.graphName);&#125;private string MergeNodeData(List&lt;NodeSerializationData&gt; nodeData)&#123;    StringBuilder sb = new StringBuilder();    for (int i = 0; i &lt; nodeData.Count; i++)    &#123;        string data = nodeData[i].Serialize();        //Debug.Log(data);        sb.Append(data);        if (i &lt; nodeData.Count - 1)        &#123;            sb.Append(&quot;|&quot;);        &#125;    &#125;    return sb.ToString();&#125;

结果因为是继承Unity的GraphView和Node，所以现在已经能自由的添加&#x2F;删除连接、添加&#x2F;删除节点了。节点编辑器的基本功能已经实现完成了。
]]></content>
  </entry>
  <entry>
    <title>Unity节点编辑器(六) -- 引导节点与引导流程</title>
    <url>/posts/3a7262dc.html</url>
    <content><![CDATA[引导流程需求目前已经有了节点和引导的遮罩，为了实现编辑步骤，还要把每一步需要高亮的位置或者需要高亮跟随的GameObject放入节点数据中，并根据节点的先后顺序逐一运行逻辑。所以就需要有3个事情：1.引导节点。目前节点编辑器只有开始节点，无法存储引导节点的数据，所以需要继承于NodeBase和数据，实现编辑器的可视化功能。2.引导节点逻辑处理脚本。为了之后的拓展性，所以针对每一种引导节点都有一个特定的处理脚本。通过维护一个状态机的生命周期，在脚本中拿到节点数据进行具体的逻辑处理。3.引导系统。我把这个写成了单例。负责加载引导数据并反序列化出来，同时也要提供根据引导名字开启引导的接口。
引导节点实现引导数据数据类继承于原来的，引导需要知道高亮指定的GameObject，数据就需要知道GameObject的ID(这里通过给对应的物体挂载脚本)，引导数据传入ID。
[Serializable]public class GuideData:NodeSerializationData&#123;    [SerializeField]    public string GuideDesc;    [SerializeField]    public long GuideID;    &#125;
引导Node引导节点继承NodeBase，需要重写InitComponent添加两个输入框编辑数据，并把数据保存起来。
public class GuideNode : NodeBase&#123;    public GuideData guideData;    private TextField textField;    private bool m_isPreview;    public override void Init(NodeSoData nodeData, NodeGraphView.NodeGraphView nodeGraphView)    &#123;        base.Init(nodeData, nodeGraphView);    &#125;    protected override void InitData()    &#123;        m_isPreview = false;        AddPortData();                if (nodeData.userData != null)        &#123;            guideData = nodeData.userData as GuideData;        &#125;        else        &#123;            guideData = new GuideData();            guideData.GuideDesc = &quot;测试文本1233&quot;;            guideData.GuideID = 10086;            nodeData.userData = guideData;        &#125;    &#125;    public override NodeSerializationData GetSerializationData()    &#123;        GuideData serializationData = new GuideData();        serializationData.GuideDesc = guideData.GuideDesc;        serializationData.GuideID = guideData.GuideID;        serializationData.nodeID =  nodeData.nodeID;        serializationData.outputPortDataList = nodeData.outputPortDataList;        serializationData.intputPortDataList = nodeData.intputPortDataList;        return serializationData;    &#125;    private void AddPortData()    &#123;        if (nodeData.intputPortDataList == null || nodeData.intputPortDataList.Count &lt;= 0)        &#123;            nodeData.AddInputPortData();        &#125;                if (nodeData.outputPortDataList == null || nodeData.outputPortDataList.Count &lt;= 0)        &#123;            nodeData.AddOutputPortData();        &#125;    &#125;    protected override void InitComponent()    &#123;        base.InitComponent();                Label label1 = new Label(&quot;高亮区域ID&quot;);        var textField1 = new TextField();        textField1.value = guideData.GuideID.ToString();        textField1.RegisterCallback&lt;ChangeEvent&lt;string&gt;&gt;(OnGuideIDChangeValue);        extensionContainer.Add(label1);        extensionContainer.Add(textField1);        Label label2 = new Label(&quot;引导文本&quot;);        extensionContainer.Add(label2);        textField = new TextField();        textField.value = guideData.GuideDesc;        textField.RegisterCallback&lt;ChangeEvent&lt;string&gt;&gt;(OnTextFieldChangeValue);        extensionContainer.Add(textField);              RefreshExpandedState();    &#125;    private void OnGuideIDChangeValue(ChangeEvent&lt;string&gt; evt)    &#123;        if (long.TryParse(evt.newValue, out long id))        &#123;            guideData.GuideID = long.Parse(evt.newValue);            Debug.Log(evt.newValue);            EditorUtility.SetDirty(nodeData);            AssetDatabase.SaveAssets();        &#125;          &#125;    private void OnTextFieldChangeValue(ChangeEvent&lt;string&gt; evt)    &#123;        guideData.GuideDesc = evt.newValue;        Debug.Log(evt.newValue);        EditorUtility.SetDirty(nodeData);        AssetDatabase.SaveAssets();    &#125;&#125;

引导节点处理脚本为了实现解耦，所以给每一个引导节点数据类都写一个唯一的数据处理脚本。
脚本基类类中维护4个状态和节点数据。4个状态初始化、运行中、结束和完成，子类通过实现4个状态内的对数据处理的具体逻辑，完成具体需求的实现。
public class GuideHandlerBase&#123;    protected GuideState m_guideState;    protected NodeSerializationData m_guideData;    protected GuideCollection m_guideCollection;    public NodeSerializationData guideData =&gt; m_guideData;    public GuideHandlerBase(NodeSerializationData data)    &#123;        m_guideData = data;    &#125;    public void SetGuideCollection(GuideCollection guideCollection)    &#123;        m_guideCollection = guideCollection;    &#125;    public void ChangeState(GuideState guideState)    &#123;        if (m_guideState == GuideState.Done)        &#123;            return;        &#125;        m_guideState = guideState;        switch (guideState)        &#123;            case GuideState.None:                break;            case GuideState.Init:            &#123;                OnInitState();            &#125;                break;            case GuideState.Running:            &#123;                OnRunningState();            &#125;                break;            case GuideState.Finish:            &#123;                OnFinishState();            &#125;                break;            case GuideState.Done:            &#123;                break;            &#125;            default:                break;        &#125;    &#125;    protected virtual void OnInitState()    &#123;        Debug.Log($&quot;节点ID=&#123;m_guideData.nodeID&#125;初始化&quot;);        m_guideCollection.AddRunningNodeID(m_guideData.nodeID);    &#125;    protected virtual void OnRunningState()    &#123;        Debug.Log($&quot;节点ID=&#123;m_guideData.nodeID&#125;运行中&quot;);    &#125;    protected virtual void OnFinishState()    &#123;        Debug.Log($&quot;节点ID=&#123;m_guideData.nodeID&#125;结束&quot;);        m_guideCollection.RemoveRunningNodeID(m_guideData.nodeID);        RunNextNode();        m_guideState = GuideState.Done;    &#125;    public void RunNextNode()    &#123;        if (m_guideCollection == null)        &#123;            Debug.LogError(&quot;guideCollectio is null!&quot;);            return;        &#125;        foreach (var portData in m_guideData.outputPortDataList)        &#123;            foreach (var linkData in portData.linkData)            &#123;                m_guideCollection.RunNode(linkData.linkNodeID);            &#125;        &#125;    &#125;&#125;
引导处理类引导类的实现比较简单，初始化的时候，实例化一个遮罩，并根据传入的引导数据内的ID找到对应高亮的GameObject进行跟随。
public class HeightLightRectGuideHandler : GuideHandlerBase&#123;    private RectMaskVertex m_RectMask;    private Transform targetObj;    private GuideData m_guideData;    public HeightLightRectGuideHandler(NodeSerializationData data) : base(data)    &#123;        if (data is GuideData guidedata)        &#123;            m_guideData = guidedata;        &#125;    &#125;        protected override void OnInitState()    &#123;        base.OnInitState();        InitGuide();        ChangeState(GuideState.Running);    &#125;    protected override void OnRunningState()    &#123;        base.OnRunningState();        if (m_RectMask == null || targetObj == null)        &#123;            return;        &#125;        m_RectMask.SetFollowTarget(targetObj.gameObject, true);    &#125;    protected override void OnFinishState()    &#123;        FinishGuide();        base.OnFinishState();    &#125;    private void InitGuide()    &#123;        m_RectMask = GuideSystem.Instance.InstantiateRectMask();        m_RectMask.name = &quot;RectMask&quot; + m_guideData.nodeID;        SetHighLight();        MessageSystem.Instance.AddMessage(MessageDefine.MASK_HIGH_LINGHT_CLICK, OnMaskHighLightClick);        MessageSystem.Instance.AddMessage(MessageDefine.MASK_CLICK, OnMaskClick);    &#125;    private void OnMaskClick()    &#123;        Debug.Log(&quot;OnMaskClick&quot;);    &#125;    private void OnMaskHighLightClick()    &#123;        ChangeState(GuideState.Finish);    &#125;    private void SetHighLight()    &#123;        if (guideData == null)        &#123;            Debug.Log($&quot;guideData is null&quot;);            return;        &#125;                targetObj = GuideSystem.Instance.GetComponent&lt;Transform&gt;(m_guideData.GuideID);        m_RectMask.SetFollowTarget(targetObj.gameObject, true);    &#125;    private void FinishGuide()    &#123;        MessageSystem.Instance.RemoveMessage(MessageDefine.MASK_CLICK, OnMaskClick);        MessageSystem.Instance.RemoveMessage(MessageDefine.MASK_HIGH_LINGHT_CLICK, OnMaskHighLightClick);        if (m_RectMask != null)        &#123;            GameObject.Destroy(m_RectMask.gameObject);            m_RectMask = null;        &#125;    &#125;&#125;

引导系统实现引导系统作为了一个单例存在，内部的两个重要功能：1、负责引导数据的记载。2、维护一个GuideRuner负责引导的运行。
加载和反序列化数据加载数据的函数比较简单，我这里直接使用了Resource.Load把对应的文件加载并通过字符串分割(分割和保存的逻辑相互对应)反序列成一个List数据。
private List&lt;GuideHandlerBase&gt; LoadData(string guideName)&#123;    string fileName = guideName + &quot;.json&quot;;    var bytesData = Resources.Load&lt;TextAsset&gt;(guideName);    var strList = bytesData.text.Split(&quot;|&quot;).ToList();    var handlerList = DeserializeObjectAndHandler(strList);    m_guideDataDic.Add(guideName, handlerList);    return handlerList;&#125;
开启引导接口引导系统中通过一个GuideRuner类负责开启。GuideRuner是一个继承于Mono的，挂载在场景的引导根节点上。内部维护了一个字典，记录着当前运行着的所有引导，并实现开始引导和移除引导的接口。
public class GuideRuner : MonoBehaviour&#123;    public EventSystem eventSystem;    public RectMaskVertex rectMsask;    private Dictionary&lt;string, GuideCollection&gt; m_RunningGuideDic =        new Dictionary&lt;string, GuideCollection&gt;();    private void Start()    &#123;        GuideSystem.Instance.StartGuide(&quot;NewGraph0&quot;);    &#125;    private void OnEnable()    &#123;        GuideSystem.Instance.SetGuideRoot(this);    &#125;    public void RunningGuide(string guideName, List&lt;GuideHandlerBase&gt; guideData)    &#123;        if (m_RunningGuideDic.TryGetValue(guideName, out GuideCollection guideCollection))        &#123;            guideCollection.ChangeState(GuideState.Init);            return;        &#125;        var newGuide = new GuideCollection(guideName, guideData,this);        m_RunningGuideDic.Add(guideName, newGuide);    &#125;    private void LateUpdate()    &#123;        // if (m_RunningGuideDic == null)        // &#123;        //     return;        // &#125;        //        // foreach (var guide in m_RunningGuideDic.Values)        // &#123;        //     if (guide == null)        //     &#123;        //         continue;        //     &#125;        //        //     guide.Update();        // &#125;    &#125;    public void RemoveGuideCollection(string guideName)    &#123;        if (m_RunningGuideDic == null || m_RunningGuideDic.Count &lt;= 0)        &#123;            return;        &#125;        if (m_RunningGuideDic.ContainsKey(guideName))        &#123;            m_RunningGuideDic.Remove(guideName);        &#125;    &#125;    public RectMaskVertex InstantiateRectMask()    &#123;        if (rectMsask == null)        &#123;            return null;        &#125;            RectMaskVertex rectMaskVertex = Instantiate&lt;RectMaskVertex&gt;(rectMsask, transform);        rectMaskVertex.SetEventSystem(eventSystem);        return rectMaskVertex;    &#125;    //    // public void RunGuide(List&lt;NodeSerializationData&gt; nodeData)    // &#123;    //     m_guideHandler.SetGuideData(nodeData);    // &#125;    //    // public void PreviewGuideNode(NodeSerializationData  nodeData)    // &#123;    //     m_guideHandler.PreviewGuideNode(nodeData);    // &#125;    //    // public void EndPreviewGuideNode()    // &#123;    //     m_guideHandler.EndPreviewGuideNode();    // &#125;&#125;
引导系统中通过调用GuideRunner的接口开启引导。
public void StartGuide(string guideName)&#123;    if (string.IsNullOrEmpty(guideName))    &#123;        return;    &#125;    var guideData = GetGuideListData(guideName);    m_guideRuner.RunningGuide(guideName, guideData);&#125;
GuideCollection因为可能存在多个引导，所以又抽象出了一个GuideCollection的数据结构。GuideCollection其实就是保存了一个引导蓝图所有的节点处理类。在构造函数中初始化，并找到蓝图中的开始节点运行。
public class GuideCollection&#123;    private string m_guideName;    private List&lt;GuideHandlerBase&gt; m_guideHandlerData;    private GuideState m_guideState;    private GuideRuner m_guideRuner;    private List&lt;long&gt; m_runningNodeID;    public GuideCollection(string guideName, List&lt;GuideHandlerBase&gt; guideHandlerData, GuideRuner guideRuner)    &#123;        m_guideName = guideName;        m_guideHandlerData = guideHandlerData;        m_guideRuner = guideRuner;        m_runningNodeID = new List&lt;long&gt;();        ChangeState(GuideState.Init);    &#125;    private bool CheckHasNodeRunning()    &#123;        return m_runningNodeID.Count &gt; 0;    &#125;    public void Update()    &#123;        if (m_guideState != GuideState.Running)        &#123;            return;        &#125;        if (!CheckHasNodeRunning())        &#123;            ChangeState(GuideState.Finish);        &#125;    &#125;    #region 对外接口    public void ChangeState(GuideState guideState)    &#123;        m_guideState = guideState;        switch (guideState)        &#123;            case GuideState.None:                break;            case GuideState.Init:            &#123;                OnInitState();            &#125;                break;            case GuideState.Running:            &#123;                OnRunningState();            &#125;                break;            case GuideState.Finish:            &#123;                OnFinishState();            &#125;                break;            default:                break;        &#125;    &#125;    public void AddRunningNodeID(long nodeID)    &#123;        if (m_runningNodeID.Contains(nodeID))        &#123;            return;        &#125;        m_runningNodeID.Add(nodeID);    &#125;    public void RemoveRunningNodeID(long nodeID)    &#123;        for (int i = m_runningNodeID.Count - 1; i &gt;= 0; i--)        &#123;            if (m_runningNodeID[i] == nodeID)            &#123;                m_runningNodeID.Remove(i);                break;            &#125;        &#125;    &#125;    #endregion    protected virtual void OnInitState()    &#123;        var startNode = GuideStartNode();        RunNode(startNode.guideData.nodeID);        // startNode.ChangeState(GuideState.Init);        // foreach (var port in startNode.guideData.outputPortDataList)        // &#123;        //     foreach (var linkNodeData in port.linkData)        //     &#123;        //         RunNode(linkNodeData.linkNodeID);        //     &#125;        // &#125;            &#125;    protected virtual void OnRunningState()    &#123;    &#125;    protected virtual void OnFinishState()    &#123;        m_guideRuner.RemoveGuideCollection(m_guideName);        Debug.Log(&quot;guide over!&quot;);    &#125;    public void RunNode(long nodeID)    &#123;        var handlerBase = GetGuideNodeDataByID(nodeID);        if (handlerBase == null)        &#123;            Debug.LogError($&quot;GuideCollection:linkNode ID =&#123;nodeID&#125; is NULL!&quot;);            return;        &#125;        handlerBase.SetGuideCollection(this);        handlerBase.ChangeState(GuideState.Init);        //return guideHandler;    &#125;    private GuideHandlerBase GuideStartNode()    &#123;        if (m_guideHandlerData == null)        &#123;            return null;        &#125;        GuideHandlerBase result = null;        foreach (var guideNode in m_guideHandlerData)        &#123;            if (guideNode.guideData.typeFullName == typeof(StartNodeData).FullName)            &#123;                result = guideNode;                break;            &#125;        &#125;        return result;    &#125;    private GuideHandlerBase GetGuideNodeDataByID(long guideID)    &#123;        if (m_guideHandlerData == null || m_guideHandlerData.Count &lt;= 0)        &#123;            return null;        &#125;        foreach (var guideNode in m_guideHandlerData)        &#123;            if (guideNode.guideData.nodeID == guideID)            &#123;                return guideNode;            &#125;        &#125;        Debug.LogError($&quot;GudieHandler:GuideID=&#123;guideID&#125; is not found&quot;);        return null;    &#125;&#125;
通过节点数据获取对应的处理脚本目前有节点数据和处理脚本，但是还有一个问题，无法将数据和对应的处理脚本一一对应起来。为了解决这个问题，我记录了一个字典，key为数据的类型，value是具体的处理脚本。在读取每个节点数据的时候，先用了NewtonJson的一个函数，统一反序列化成基类，再通过的数据中记录类名与字典的key的类型比较是否相同，从而获得对应的处理脚本。
private List&lt;GuideHandlerBase&gt; LoadData(string guideName)&#123;    string fileName = guideName + &quot;.json&quot;;    var bytesData = Resources.Load&lt;TextAsset&gt;(guideName);    var strList = bytesData.text.Split(&quot;|&quot;).ToList();    var handlerList = DeserializeObjectAndHandler(strList);    m_guideDataDic.Add(guideName, handlerList);    return handlerList;&#125;private List&lt;GuideHandlerBase&gt; DeserializeObjectAndHandler(List&lt;string&gt; objectStrList)&#123;    if (objectStrList == null || objectStrList.Count &lt;= 0)    &#123;        return null;    &#125;    var nodeDataList = new List&lt;GuideHandlerBase&gt;();    foreach (var objectStr in objectStrList)    &#123;        // 首先尝试解析为基础数据以获取类型信息        var baseData = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;NodeSerializationData&gt;(objectStr);        if (baseData == null)        &#123;            Debug.LogError(&quot;无法反序列化基础数据&quot;);            continue;        &#125;        // 根据类型全名找到对应的类型        Type targetType = null;        foreach (var typeItem in m_guideTypeMap)        &#123;            if (typeItem.Key.FullName.Equals(baseData.typeFullName))            &#123;                targetType = typeItem.Key;                break;            &#125;        &#125;        if (targetType == null)        &#123;            Debug.LogError($&quot;未找到匹配的类型: &#123;baseData.typeFullName&#125;&quot;);            continue;        &#125;        // 使用正确的类型进行反序列化        var saveData = Newtonsoft.Json.JsonConvert.DeserializeObject(objectStr, targetType);        if (saveData == null)        &#123;            Debug.LogError($&quot;无法反序列化为目标类型: &#123;targetType.FullName&#125;&quot;);            continue;        &#125;        // 创建处理器实例        if (!m_guideTypeMap.TryGetValue(targetType, out Type handlerType))        &#123;            Debug.LogError($&quot;未找到类型 &#123;targetType.FullName&#125; 对应的处理器类型&quot;);            continue;        &#125;        var handler = Activator.CreateInstance(handlerType, saveData) as GuideHandlerBase;        if (handler == null)        &#123;            Debug.LogError($&quot;无法创建处理器实例: &#123;handlerType.FullName&#125;&quot;);            continue;        &#125;        nodeDataList.Add(handler);    &#125;    return nodeDataList;&#125;]]></content>
  </entry>
  <entry>
    <title>Unity颜色空间:sRGB和Linear</title>
    <url>/posts/b73f5a7a.html</url>
    <content><![CDATA[发现问题最近在项目中遇到一个问题，就是一张显示正常的图片，放到了UI中莫名其妙的就显示偏黑了，就像这样经过询问同事后发现，原来项目的相机是使用的Linear空间。
sRGB和Linear在物理世界中，如果光增加一倍，那么亮度也增加一倍，这是线性关系。但是在最早的显示器中，显示图像的时候，电压增加一倍，亮度并不是跟着增加一倍，而是呈亮度增加量等于电压增加量的2.2次幂的非线性关系:&nbsp;&nbsp;l_亮度&#x3D;u2.2&nbsp;&nbsp;&nbsp;&nbsp;(l ∈[0,1],u∈[0,1])2.2也叫做显示器的Gamma值。因为亮度0是黑，1是白，这种关系意味着当电压线性变化的时候，相对于真实的世界来说，亮度的变化在暗处黑的地方变换比较慢，暗占据数据范围更广，颜色整体偏暗。如图，直线代表物理世界的线性空间（Linear Space），下曲线是显示器输出的Gamma2.2空间（Gamma Space）。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;横坐标表示电压，纵坐标表示亮度
常情况下，人眼看物理世界感知到了正常的亮度。而如果显示器输出一个颜色后再被你看到，即相当于走了一次Gamma2.2曲线的调整，这下子颜色就变暗了。如果我们在显示器输出之前，做一个操作把显示器的Gamma2.2影响平衡掉，那就和人眼直接观察物理世界一样了！这个平衡的操作就叫做伽马校正。在数学上，伽马校正是一个约0.45的幂运算（和上面的2.2次幂互为逆运算）:&nbsp;&nbsp;Co &#x3D; Ci1&#x2F;2.2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左(Gamma0.45) 中(Gamma2.2) 右(线性物理空间)
Linear转换过程Linear空间的转换过程遵循下图:第一步，输入的纹理如果是sRGB（Gamma0.45），那我们要进行一个操作转换到线性空间。这个操作叫做Remove Gamma Correction，在数学上是一个2.2的幂运算 。如果输入不是sRGB，而是已经在线性空间的纹理了呢？那就可以跳过Remove Gamma Correction了。注：美术输出资源时都是在sRGB空间的，但Normal Map等其他电脑计算出来的纹理则一般在线性空间，即Linear Texture。
第二步，现在输入已经在线性空间了，那么进行Shader中光照、插值等计算后就是比较真实的结果了，如果不对sRGB进行Remove Gamma Correction直接就进入Shader计算，那算出来的就会不自然。
第三步，Shader计算完成后，需要进行Gamma Correction，从线性空间变换到Gamma0.45空间，在数学上是一个约为0.45的幂运算。如果不进行Gamma Correction输出会怎么样？那显示器就会将颜色从线性空间转换到Gamma2.2空间，接着再被你看到，结果会更暗。我遇到问题的原因！
第四步，经过了前面的Gamma Correction，显示器输出在了线性空间，这就和人眼看物理世界的过程是一样的了！
问题解决知道了sRGB和Linear的底层原理和变暗的原因，那么解决方案也就清晰明了：因为相机是Linear空间，会对输入进行一次Gamma2.2的操作。如果我们这里想要看到正常的图片，就有两种解决方案：
如果在运行时截图显示：对显示的Texuture2D，进行一次Gamma0.45去和Remove Gamma Correction的Gamma2.2抵消(因为我也是运行时改图，这也是我采用的方案)。最终效果
如果是读取编辑器的图片：直接在Inspector面板取消sRGB选项，Unity会做一次Gamma0.45，然后在Unity编辑器中看到的图片是偏白的。
Gamma0.45的代码public Texture2D RecoverOriginalTexture(Texture2D gammaTexture)&#123;    // 创建新纹理（使用线性空间）    Texture2D recoveredTexture = new Texture2D(        gammaTexture.width,        gammaTexture.height,        TextureFormat.RGBA32,        false, // 不生成mipmaps        true   // 线性空间    );    // 获取像素数据    Color[] pixels = gammaTexture.GetPixels();    // 应用复原转换,直接进行0.45次方    for (int i = 0; i &lt; pixels.Length; i++)    &#123;        pixels[i] = RecoverGamma22Simple(pixels[i],0.45f);    &#125;    // 应用处理后的像素    recoveredTexture.SetPixels(pixels);    recoveredTexture.Apply();    return recoveredTexture;&#125;// 复原函数public Color RecoverGamma22Simple(Color gammaColor,float rate)&#123;    return new Color(        Mathf.Pow(gammaColor.r, rate),        Mathf.Pow(gammaColor.g, rate),        Mathf.Pow(gammaColor.b, rate),        gammaColor.a    );&#125;

参考资料[1].Gamma、Linear、sRGB 和Unity Color Space，你真懂了吗？
]]></content>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/posts/ff05b5bf.html</url>
    <content><![CDATA[为什么弄博客自从工作以来，一些记忆性的东西越来越多，再加上自己平时积累的东西，之前一直都是用一些第三方的笔记软件记录，但这样进行分享的时候就特别不方便，越来越需要一个地方记录下来，但是国内写到某DN博客，总觉得文章就变成不是自己的，心里不舒服。刚好最近看到了一些个人博客搭建的教程，有非常方便的工具可以快速部署。所以趁着周末有空，搭建了这个博客，之后用来记录和分享技术文档。每天进步一点，做更好的自己！
]]></content>
  </entry>
  <entry>
    <title>算法--判断点是否在多边形中(包含凹凸多边形)</title>
    <url>/posts/ca3fa1d1.html</url>
    <content><![CDATA[判断点是否在一个凸多边形内部，可以根据面积、叉乘的方法判断。但是包括凹多边形的时候，就得使用射线法判断。下面介绍这种算法。
算法原理奇-偶规则（Odd-even Rule）：奇数表示在多边形内，偶数表示在多边形外从任意位置p作任意方向的一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点。以上图为例：从红点向任意方向发射射线(上图是向左和向右)，与图形的边的交点总和为奇数时，点在内部；为偶数时，点在外部。（上图向左有5个点，向右有3个点），所以红点在多边形的内部。所以，问题就从判断点在多边形的内部转化为了：判断点朝任意方向的射线与多边形的边的交点个数的奇、偶问题。
如何判断射线与多边形的交点？从上图可以非常直观地看出，取出多边形中两个相邻的点P1、P2，根据两点得到直线的方程为：Y&#x3D;(y1-y2)&#x2F;(X1-X2)*（X - X1）+Y1。将待监测点P0的X0代入直线方程（如果向上打射线）,计算出X0在该射线上的Y位置，如果Y&gt;Y0则说明：该P0点在线段P1、P2的下方，交点数+1；反之则为下方。
代码实现public static bool checkPosInPolygon(List&lt;Vector3&gt; PosList, Vector3 checkPos)&#123;    if (PosList == null || PosList.Count &lt;= 0)    &#123;        return false;    &#125;    int num = 0;    for (int i = 0; i &lt; PosList.Count; i++)    &#123;        Vector3 curPos = PosList[i] ;        Vector3 nextPos = PosList[(i + 1) % PosList.Count] ;        if (checkPos.y &gt;= Mathf.Max(curPos.y, nextPos.y) || checkPos.y &lt;= Mathf.Min(curPos.y, nextPos.y))        &#123;            continue;        &#125;        float lineSlope = (curPos.x - nextPos.x) / (curPos.y - nextPos.y);        float linePosx = (checkPos.y - curPos.y) * lineSlope + curPos.x;        if (linePosx &lt; checkPos.x || Mathf.Approximately(linePosx, checkPos.x))        &#123;            num++;        &#125;    &#125;    return (num % 2 != 0);&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/style.css</url>
    <content><![CDATA[#footer
{
    background: transparent;
}

.footer-other
{
    color: black !important;
}]]></content>
  </entry>
</search>
